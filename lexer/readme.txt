README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should now contain the following files:

 Makefile        -> [course dir]/src/PA2/Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [course dir]/src/PA2/lextest.cc
 mycoolc         -> [course dir]/src/PA2/mycoolc
 stringtab.cc    -> [course dir]/src/PA2/stringtab.cc
 utilities.cc    -> [course dir]/src/PA2/utilities.cc
 handle_flags.cc -> [course dir]/src/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[course dir]/include/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the make
 	documentation for a detailed explanation.


	1) check_length function(line 45 and 207)
	this function simply just check the length of string buffer using
	the place of string_buf_ptr in memory and first of string buffer.
	if it's not exceed the max size, return true. whether else, false.


	2) state definition(line 49 & 50) 
	other state that our lexer should have, are when lexer enter 
	string or comment. we know that this shouldn't act as INITIAL
	and run command in string or comment.


	3) INITIAL state re(line 69 to 127)
	now let's define our re patterns and assign a function to each of
	them. for kewwords, as in cool.flex comment said, it's 
	case-insensitive so all possible combination of uppercase and 
	lowercase letter are valid and include in re pattern written.
	
	for boleans, Objects and Types just returning it's number can't 
	help us later in parser phaze. so we save them in table that 
	is already in our project.
	for boleans we set true or false in cool_yylval.boolean variable.
	for object and types we must add them to idtable and set it to
	cool_yylval.symbol. integers are another type that their value 
	must be saved for future use.
	
	another simple, but important thing that must be handled, is lineno.
	we count a counter called curr_lineno that increase where ever lexer
	detect a '\n'. it don't matter that it's in which state INITIAL, 
	STRING or COMMENT. 


	4) STRING state re (line 128 to 191)
	when lexer detect \" character, it must enter this state called 
	STRING. in this state, we shouldn't see end of file(EOF) and \n.
	both are error as the rules of cool progrming language.
	
	for error reporting, we have a code for EEROR that we already include 
	in our project. we must just add our error massage to 
	cool_yylval.error_msg and then just return ERROR number.

	\0 is another error that we might see as we are in string state. 
	
	\\n is a pattern that check whether our string contains backslash
	and handle it.
	
	any remainig character in string must be add to string buffer.
	string buffer is an array with pointer moving on it and pointing
	to the last place of it and we put our characters one by one in it.
	each time we begin a new string, pointer should get to the start
	address and start filling it.
	

	5) COMMENT state re (line 193 to 201)
	as we see in string section, with (* we enter this state and 
	ignore each character we see. like the string state we can't have
	end of file in this state.


Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.


        Instructions for turning in the assignment will be posted on the
        course web page.

        GOOD LUCK!

